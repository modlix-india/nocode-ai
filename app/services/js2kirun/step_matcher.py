"""
Step Matcher for preserving step names during JS-to-KIRun conversion.

This module extracts step names from JavaScript comments (// Step: stepName)
and remaps generated step names to preserve the original names.
"""
import re
from typing import Dict, Any, List, Optional, Tuple


def extract_step_names_from_js(js_code: str) -> Dict[int, str]:
    """
    Extract step names from JavaScript code comments.
    
    Parses lines looking for '// Step: stepName' comments and maps
    line numbers to step names.
    
    Args:
        js_code: JavaScript code with step comments
        
    Returns:
        Dictionary mapping line numbers (0-based) to step names
    """
    step_names = {}
    lines = js_code.split('\n')
    
    # Pattern to match '// Step: stepName' at end of line
    pattern = re.compile(r'//\s*Step:\s*(\w+)\s*$')
    
    for i, line in enumerate(lines):
        match = pattern.search(line)
        if match:
            step_names[i] = match.group(1)
    
    return step_names


def extract_step_name_from_comment(js_line: str) -> Optional[str]:
    """
    Extract step name from a single line's comment.
    
    Args:
        js_line: A single line of JavaScript code
        
    Returns:
        Step name if found, None otherwise
    """
    match = re.search(r'//\s*Step:\s*(\w+)', js_line)
    return match.group(1) if match else None


def build_step_name_mapping(
    js_code: str,
    generated_steps: Dict[str, Dict[str, Any]]
) -> Dict[str, str]:
    """
    Build a mapping from generated step names to original step names.
    
    This function:
    1. Parses the JS code to find all step comments
    2. Matches them to generated steps by order
    3. Returns a mapping to remap step names
    
    Args:
        js_code: JavaScript code with step comments
        generated_steps: Steps generated by the converter
        
    Returns:
        Dictionary mapping generated step name -> original step name
    """
    # Extract step names from JS code in order
    step_comments = extract_step_names_from_js(js_code)
    original_names = [name for _, name in sorted(step_comments.items())]
    
    # Get generated step names in order (by position if available, else by key)
    generated_names = _get_ordered_step_names(generated_steps)
    
    # Build mapping
    mapping = {}
    
    for i, gen_name in enumerate(generated_names):
        if i < len(original_names):
            orig_name = original_names[i]
            if orig_name != gen_name:
                mapping[gen_name] = orig_name
    
    return mapping


def _get_ordered_step_names(steps: Dict[str, Dict[str, Any]]) -> List[str]:
    """
    Get step names ordered by their position or definition order.
    
    Args:
        steps: Step definitions
        
    Returns:
        List of step names in order
    """
    # Try to order by position.top if available
    step_positions = []
    for name, step in steps.items():
        pos = step.get('position', {})
        top = pos.get('top', 0) if isinstance(pos, dict) else 0
        step_positions.append((name, top))
    
    # Sort by position
    step_positions.sort(key=lambda x: x[1])
    
    return [name for name, _ in step_positions]


def remap_step_names(
    func_def: Dict[str, Any],
    name_mapping: Dict[str, str]
) -> Dict[str, Any]:
    """
    Remap step names in a function definition.
    
    Updates:
    - Step keys in the 'steps' dictionary
    - 'statementName' field in each step
    - References in 'dependentStatements'
    - References in expressions (Steps.oldName -> Steps.newName)
    
    Args:
        func_def: Function definition with generated names
        name_mapping: Mapping of old_name -> new_name
        
    Returns:
        Function definition with remapped names
    """
    if not name_mapping:
        return func_def
    
    steps = func_def.get('steps', {})
    new_steps = {}
    
    for old_name, step in steps.items():
        # Determine new name
        new_name = name_mapping.get(old_name, old_name)
        
        # Create new step with updated name
        new_step = dict(step)
        new_step['statementName'] = new_name
        
        # Update dependentStatements
        if 'dependentStatements' in new_step:
            new_step['dependentStatements'] = _remap_dependencies(
                new_step['dependentStatements'],
                name_mapping
            )
        
        # Update expressions that reference Steps.oldName
        new_step = _remap_step_references_in_params(new_step, name_mapping)
        
        new_steps[new_name] = new_step
    
    # Return updated function definition
    result = dict(func_def)
    result['steps'] = new_steps
    return result


def _remap_dependencies(
    deps: Dict[str, Any],
    name_mapping: Dict[str, str]
) -> Dict[str, Any]:
    """
    Remap step names in dependentStatements.
    
    Dependency keys are like 'Steps.stepName.output'
    """
    new_deps = {}
    
    for dep_key, dep_value in deps.items():
        # Parse the dependency path
        parts = dep_key.split('.')
        if len(parts) >= 2 and parts[0] == 'Steps':
            old_step_name = parts[1]
            new_step_name = name_mapping.get(old_step_name, old_step_name)
            parts[1] = new_step_name
            new_key = '.'.join(parts)
        else:
            new_key = dep_key
        
        new_deps[new_key] = dep_value
    
    return new_deps


def _remap_step_references_in_params(
    step: Dict[str, Any],
    name_mapping: Dict[str, str]
) -> Dict[str, Any]:
    """
    Remap Steps.xxx references in parameter expressions.
    """
    param_map = step.get('parameterMap', {})
    if not param_map:
        return step
    
    new_param_map = {}
    
    for param_name, param_entries in param_map.items():
        new_entries = {}
        for entry_key, entry in param_entries.items():
            new_entry = dict(entry)
            
            # Check for expressions
            if 'expression' in new_entry:
                expr = new_entry['expression']
                new_entry['expression'] = _remap_steps_in_expression(expr, name_mapping)
            
            # Check for value that might contain step references
            if 'value' in new_entry and isinstance(new_entry['value'], str):
                value = new_entry['value']
                if value.startswith('Steps.'):
                    new_entry['value'] = _remap_steps_in_expression(value, name_mapping)
            
            new_entries[entry_key] = new_entry
        
        new_param_map[param_name] = new_entries
    
    result = dict(step)
    result['parameterMap'] = new_param_map
    return result


def _remap_steps_in_expression(expr: str, name_mapping: Dict[str, str]) -> str:
    """
    Remap Steps.xxx references in an expression string.
    
    Handles patterns like:
    - Steps.fetchData.output.data
    - Steps.setStore1.output
    """
    if not expr or 'Steps.' not in expr:
        return expr
    
    # Pattern to match Steps.stepName
    pattern = re.compile(r'Steps\.(\w+)')
    
    def replace_step(match):
        old_name = match.group(1)
        new_name = name_mapping.get(old_name, old_name)
        return f'Steps.{new_name}'
    
    return pattern.sub(replace_step, expr)


def preserve_step_names(
    js_code: str,
    func_def: Dict[str, Any],
    original_func: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Main function to preserve step names and positions from JS comments.
    
    This is the main entry point that:
    1. Extracts step names from JS comments
    2. Builds a mapping from generated to original names
    3. Remaps all step references
    4. Preserves original step positions (or generates new ones)
    
    Args:
        js_code: JavaScript code with step comments
        func_def: Converted function definition with generated names
        original_func: Original function definition (to preserve positions)
        
    Returns:
        Function definition with preserved step names and positions
    """
    # Extract step names from comments
    step_comments = extract_step_names_from_js(js_code)
    
    # Get the steps
    steps = func_def.get('steps', {})
    
    if not steps:
        return func_def
    
    result = func_def
    
    if step_comments:
        # Build mapping based on order
        original_names = [name for _, name in sorted(step_comments.items())]
        generated_names = _get_ordered_step_names(steps)
        
        # Create mapping
        name_mapping = {}
        for i, gen_name in enumerate(generated_names):
            if i < len(original_names):
                orig_name = original_names[i]
                if orig_name != gen_name:
                    name_mapping[gen_name] = orig_name
        
        if name_mapping:
            # Apply remapping
            result = remap_step_names(func_def, name_mapping)
    
    # Preserve positions from original function or generate new ones
    if original_func:
        result = _preserve_positions(result, original_func)
    else:
        # No original function - ensure all steps have positions
        result = _ensure_all_positions(result)
    
    return result


def _ensure_all_positions(func_def: Dict[str, Any]) -> Dict[str, Any]:
    """
    Ensure all steps have positions. Generate them if missing.
    """
    steps = func_def.get('steps', {})
    if not steps:
        return func_def
    
    # Check if any step is missing a position
    missing_steps = [name for name, step in steps.items() if 'position' not in step]
    
    if not missing_steps:
        return func_def
    
    # Get existing positions
    existing_positions = {
        name: step['position']
        for name, step in steps.items()
        if 'position' in step
    }
    
    # Make a copy with new positions
    new_steps = {name: dict(step) for name, step in steps.items()}
    
    _generate_missing_positions(new_steps, missing_steps, existing_positions)
    
    result = dict(func_def)
    result['steps'] = new_steps
    return result


def _preserve_positions(
    func_def: Dict[str, Any],
    original_func: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Preserve step positions from the original function definition.
    
    For each step in the converted function, if there's a matching step
    in the original function (by name), copy its position. For new steps,
    generate positions based on dependencies and existing positions.
    
    Args:
        func_def: Converted function definition
        original_func: Original function definition with positions
        
    Returns:
        Function definition with preserved positions
    """
    original_steps = original_func.get('steps', {})
    steps = func_def.get('steps', {})
    
    if not steps:
        return func_def
    
    new_steps = {}
    steps_with_positions = {}
    steps_without_positions = []
    
    # First pass: copy positions from original steps
    for step_name, step in steps.items():
        new_step = dict(step)
        
        # Check if this step exists in the original function
        if step_name in original_steps:
            original_step = original_steps[step_name]
            
            # Preserve position
            if 'position' in original_step:
                new_step['position'] = original_step['position']
                steps_with_positions[step_name] = new_step['position']
        
        new_steps[step_name] = new_step
    
    # Identify steps without positions
    for step_name, step in new_steps.items():
        if 'position' not in step:
            steps_without_positions.append(step_name)
    
    # Generate positions for steps without them
    if steps_without_positions:
        _generate_missing_positions(
            new_steps, 
            steps_without_positions, 
            steps_with_positions
        )
    
    result = dict(func_def)
    result['steps'] = new_steps
    return result


def _generate_missing_positions(
    steps: Dict[str, Any],
    missing_steps: List[str],
    existing_positions: Dict[str, Dict[str, float]]
) -> None:
    """
    Generate positions for steps that don't have them.
    
    Strategy:
    1. If there are existing positions, place new steps relative to their dependencies
    2. If no existing positions, generate a clean left-to-right, top-to-bottom layout
    
    Args:
        steps: All steps (will be mutated to add positions)
        missing_steps: Names of steps that need positions
        existing_positions: Map of step name -> position for steps that have them
    """
    # Default layout constants
    DEFAULT_LEFT_START = 100
    DEFAULT_TOP_START = 100
    HORIZONTAL_SPACING = 300
    VERTICAL_SPACING = 150
    MAX_COLUMNS = 4
    
    if existing_positions:
        # Find the bounds of existing positions
        max_left = max(pos.get('left', 0) for pos in existing_positions.values())
        max_top = max(pos.get('top', 0) for pos in existing_positions.values())
        
        # Place new steps based on their dependencies
        for step_name in missing_steps:
            step = steps[step_name]
            position = _calculate_position_from_dependencies(
                step_name, 
                step, 
                steps,
                existing_positions,
                max_left,
                max_top
            )
            step['position'] = position
            existing_positions[step_name] = position
    else:
        # No existing positions - generate a complete layout
        # Sort steps by dependencies (topological order)
        sorted_steps = _topological_sort_for_layout(steps)
        
        # Assign positions in a grid layout
        for i, step_name in enumerate(sorted_steps):
            if step_name in steps:
                col = i % MAX_COLUMNS
                row = i // MAX_COLUMNS
                
                position = {
                    'left': DEFAULT_LEFT_START + (col * HORIZONTAL_SPACING),
                    'top': DEFAULT_TOP_START + (row * VERTICAL_SPACING)
                }
                steps[step_name]['position'] = position


def _calculate_position_from_dependencies(
    step_name: str,
    step: Dict[str, Any],
    all_steps: Dict[str, Any],
    existing_positions: Dict[str, Dict[str, float]],
    max_left: float,
    max_top: float
) -> Dict[str, float]:
    """
    Calculate position for a step based on its dependencies.
    
    Place the step below/right of its dependencies.
    """
    HORIZONTAL_OFFSET = 300
    VERTICAL_OFFSET = 150
    
    # Get dependencies
    deps = step.get('dependentStatements', {})
    dep_positions = []
    
    for dep_path in deps.keys():
        parts = dep_path.split('.')
        if len(parts) >= 2 and parts[0] == 'Steps':
            dep_name = parts[1]
            if dep_name in existing_positions:
                dep_positions.append(existing_positions[dep_name])
    
    # Also check for implicit dependencies (Steps.xxx references in params)
    param_map = step.get('parameterMap', {})
    for param_values in param_map.values():
        if isinstance(param_values, dict):
            for val in param_values.values():
                if isinstance(val, dict):
                    expr = val.get('expression', '')
                    if isinstance(expr, str) and 'Steps.' in expr:
                        # Extract step name
                        import re
                        for match in re.finditer(r'Steps\.(\w+)', expr):
                            ref_step = match.group(1)
                            if ref_step in existing_positions and ref_step != step_name:
                                dep_positions.append(existing_positions[ref_step])
    
    if dep_positions:
        # Place below and slightly right of the rightmost dependency
        rightmost = max(dep_positions, key=lambda p: p.get('left', 0))
        return {
            'left': rightmost.get('left', 0) + HORIZONTAL_OFFSET,
            'top': rightmost.get('top', 0) + VERTICAL_OFFSET
        }
    else:
        # No dependencies found - place at the bottom right of existing steps
        return {
            'left': max_left + HORIZONTAL_OFFSET,
            'top': max_top + VERTICAL_OFFSET
        }


def _topological_sort_for_layout(steps: Dict[str, Any]) -> List[str]:
    """
    Sort steps topologically based on dependencies for layout purposes.
    """
    from collections import deque
    
    # Build dependency graph
    in_degree = {name: 0 for name in steps}
    graph = {name: [] for name in steps}
    
    for name, step in steps.items():
        deps = step.get('dependentStatements', {})
        for dep_path in deps.keys():
            parts = dep_path.split('.')
            if len(parts) >= 2 and parts[0] == 'Steps':
                dep_name = parts[1]
                if dep_name in steps:
                    graph[dep_name].append(name)
                    in_degree[name] += 1
    
    # Kahn's algorithm
    queue = deque([name for name, degree in in_degree.items() if degree == 0])
    result = []
    
    while queue:
        current = queue.popleft()
        result.append(current)
        
        for neighbor in graph[current]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Add any remaining steps (cycles or disconnected)
    for name in steps:
        if name not in result:
            result.append(name)
    
    return result

